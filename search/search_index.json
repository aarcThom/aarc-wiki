{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"gh/data-management/","title":"Data Management","text":"<p>This page is very much a WIP. For 2024 ARCH 517 students, please refer to the \"Data Management\" Presentation uploaded to canvas and the further reading / viewing below. </p> <p> </p> This image will make sense when I flesh everything out!"},{"location":"gh/data-management/#01-grasshopper-lists","title":"01 - Grasshopper Lists","text":""},{"location":"gh/data-management/#further-reading-and-viewing","title":"Further Reading and Viewing","text":"<ul> <li>ModeLab - Grasshopper Primer - Working with Lists</li> <li>Learn Visual Programming - Grasshopper101: #05 Data Lists Videos</li> <li>TU Delft - Grasshopper Basic List Actions</li> <li>Danil Nagy - Working with Lists</li> </ul>"},{"location":"gh/data-management/#02-grasshopper-data-trees-aka-nested-lists-as-discussed-in-class","title":"02 - Grasshopper Data Trees (AKA nested Lists as discussed in class)","text":""},{"location":"gh/data-management/#further-reading-and-viewing_1","title":"Further Reading and Viewing","text":"<ul> <li>ModeLab - Grasshopper Primer - Designing with Data Trees</li> <li>Gediminas Kirdeikis - Data Trees for Beginners (Rhino + Grasshopper)</li> <li>ShapeDiver - Grasshopper Data Trees Explained!</li> <li>The Different Design - Graft, Flatten and Data Trees</li> </ul>"},{"location":"gh/first-definition/","title":"Basic Grasshopper Functionality","text":"<p>For the first real definition we cover, we are going to make a widget to put into practice what was covered in the previous interface section. Moreso, this widget will demonstrate in a toy manner, some of the major uses of Grasshopper. See this link for the file.</p> <p>We will cover this and future definitions, step by step. Refer to the numbered component groups in the image below.</p> <p> </p> How to make a Widget Using Grasshopper"},{"location":"gh/first-definition/#01-how-a-geometry-component-works","title":"01 - How a Geometry Component Works","text":""},{"location":"gh/first-definition/#01a-parallels-with-a-rhino-command","title":"01A - Parallels with a Rhino Command","text":"<p>A single component in Grasshopper often roughly corresponds to a command in Rhino.  For example, run the Rhino command <code>Sphere</code>. You will be taken through a 2 step process via the Rhino command line.</p> <ol> <li>Rhino will first prompt you for the center of the sphere which you can provide either with your cursor or with coordinates through the command line.</li> <li>Rhino will prompt you for a radius which you can provide in one of the two ways above.</li> </ol> <p></p> <p>Grasshopper provides an analogous component, also named <code>Sphere</code>. To use it, open Grasshopper, click the Surface tab, then the Primitive dropdown menu, and select <code>Sphere</code>.</p> <p></p> <p>Take a look at the component on the canvas. Remembering that Grasshopper flows from left to right, we can intuit that we have 2 inputs: Base and Radius. Our single output, Sphere is the geometry itself. This Grasshopper component requires the same inputs to create the same output as the corresponding Rhino command.</p> <p></p> <p>This is fundamentally how Grasshopper works. We use components as flexible and non-destructive (parametric) stand-ins for commands we traditionally run through Rhino. In other words, once you've created that sphere in Rhino, you can't modify its properties without resorting to other additional commands such as <code>scale3D</code>, Ctrl+Z, etc. With Grasshopper, we can tweak the inputs to the sphere all day long!</p>"},{"location":"gh/first-definition/#01b-how-component-geometry-is-represented-visually","title":"01B - How Component Geometry is Represented Visually","text":""},{"location":"gh/first-definition/#viewport-representation","title":"Viewport Representation","text":"<p>Grasshopper geometry is represented much differently that Rhino geometry. To see this, zoom in towards the origin of your Rhino viewport. You'll see a translucent red sphere. Click the <code>Sphere</code> component, and the translucent sphere will turn green. This little ghostly sphere corresponds to the <code>Sphere</code> component.</p> <p></p> <p>Grasshopper geometry is a representation of geometry within a component</p> <p>If a Grasshopper component creates, alters, or reorganizes geometry, there will be a corresponding representation in the Rhino viewport. This representation will be green if the component is selected in the GH canvas and red if the component is not selected in the canvas.</p> <p>Now, if you try clicking on the Grasshopper sphere in Rhino, what happens? Nothing! You cannot interact with the Grasshopper geometry directly in Rhino in this way. Think back to that one undergrad philosophy course you took, and recall an allegory about a cave (but don't recall it too well!) Rhino representations of Grasshopper geometry are just that, representations of specific points in your parametric modeling process.</p> <p> </p> This is EXACTLY how Grasshopper works under the hood <p>To illustrate the point that Rhino previews of Grasshopper geometry are representations, try placing a <code>Move</code> component onto the canvas, and hooking the output of <code>Sphere</code> into the <code>Geometry</code> input. You will see that both the original <code>Sphere</code> geometry and the new sphere, output from <code>Move</code> are present in the viewport. </p> <p></p> <p>Both spheres present in the viewport are representations of specific steps of the modeling process. This hilights another important point:</p> <p>Grasshopper components are non-destructive</p> <p>A grasshopper component does not erase the geometry or information contained in the previous step. Every step of the parametric modeling process is retained.</p> <p>We will get into ways we can interact with Grasshopper through the Rhino viewport, when we talk about referencing geometry, but in general, the primary way that we interact with Grasshopper geometry is through the Grasshopper canvas.</p>"},{"location":"gh/first-definition/#preview","title":"Preview","text":"<p>Since the geometry we see in the Rhino viewport is a representation, we are able to turn on and off its visibility without effecting the geometry actually contained within the component. Try rmb <code>Sphere</code> and toggling preview.</p> <p></p> <p>When we toggle preview we are toggling whether or not the geometry representation is visible in Rhino. Turning off preview does not alter the underlying Grasshopper geometry or affect the following components.</p> <p>Also note that when a component's preview is turned off, the component itself becomes a slightly darker shade of grey.</p> <p></p>"},{"location":"gh/first-definition/#enable","title":"Enable","text":"<p>When we toggle enable we are toggling both the Rhino preview and the actual Grasshopper component. You can see that both spheres dissapear since <code>Move</code> doesn't have the original sphere flowing into it. Disabling a component disables the underlying geometry and makes the component's information unavailable to downstream components.</p> <p></p> <p>When a component is disabled, it takes on a more muted gray scheme. The orange wire also indicates that no data is flowing from the disabled component's output.</p> <p></p>"},{"location":"gh/first-definition/#delete","title":"Delete","text":"<p>Finally, deleting a component from the canvas, will wipe its corresponding representation from the viewport, and make the now-deleted information unavailable to all downstream components. I'm deleting the <code>Sphere</code> in the .gif below, but try deleting the <code>Move</code> component to follow along with the next steps. You just lmb <code>Move</code> and hit Del.</p> <p></p>"},{"location":"gh/first-definition/#01c-how-component-information-is-represented-textually","title":"01C - How Component Information is Represented Textually","text":"<p>While textual representations of geometry may seem overkill at this point, the textual representations of component data are often more useful than visual representations in the viewport. This will become more apparent when we start considering the organization of data within a definition, but even at this point, we can use these menus to learn the inputs and outputs of a specific component. Hover over the inputs, outputs, and icon of <code>Sphere</code>.</p> <p></p> <p>Hover over everything</p> <p>In the input and output boxes shown above, we are shown three important pieces of data. Going from top to bottom:</p> <ol> <li>The name of the input or output.</li> <li>A description of what sort of data can be passed through the input or output.</li> <li>A description of the data currently flowing through an input or output.</li> </ol>"},{"location":"gh/first-definition/#01d-baking","title":"01D - Baking","text":"<p>We've covered how the representations of Grasshopper geometry are not Rhino geometry. But how do we then bring our GH work into Rhino so we can finish our project? We bake it! Baking refers to converting Grasshopper geometry to Rhino geometry.</p> <p> </p> The joys of baking <p>To bring geometry from Grasshopper into Rhino at any step of your definition, rmb the component you want to bake and select \ud83c\udf73Bake.</p> <p>This will bring up the generically titled Attributes window. Here, you can select which layer you want to bake your selected Grasshopper geometry to. You can also choose to group the geometry or set some display options.</p> <p></p> <p>You have now created a Rhino object from the component you baked that you can interact with in Rhino. Note, that this Rhino object that you have just baked exists totally independently of all your Grasshopper geometry. You can delete or transform it without any side effects in the Grasshopper canvas.</p>"},{"location":"gh/first-definition/#02-03-setting-parameters","title":"02 / 03 - Setting Parameters","text":"<p>Parameters in the context of Grasshopper refer to 2 things:</p> <ol> <li> <p>Parameters are the variables of a Grasshopper definition. Think back to high school math - the function \\(y=sin(x)\\) has a parameter or        variable \\(x\\). As \\(x\\) changes, the output \\(y\\) also changes. In this analogy, \\(y\\) is the geometry we will utlimately bake into Rhino, \\(sin()\\) is our Grasshopper definition, and \\(x\\) are our input parameters. However, in Grasshopper, instead of just numbers, we are able to pass geometry, text, user interaction and all sorts of things in as parameters. </p> </li> <li> <p>We also use the terms parameter to refer to the Grasshopper components which are used to pass in values. These special components are handily stored in the parameters tab. </p> </li> </ol> <p>Parameters &amp; Components - What's the Difference</p> <p>All the little 'nodes' that make up a Grasshopper definition (script) are called components. Parameters are a class of component that either reference data from Rhino, reference data from outside of Rhino / Grasshopper, or reference user input.</p> <p>In this section of our definition, we are using 3 <code>Number Slider</code> parameters to define the X, Y, and Z values of a 3D point. To convert these values into the geometric point, we use <code>Construct Point</code>. </p> <p>We also use a <code>Number Slider</code> to define the Radius of the <code>Sphere</code>.</p> <p></p> <p>The output of <code>Construct Point</code> is plugged into the the Base input of the <code>Sphere</code> component.</p> <p>Grasshopper Type Conversions</p> <p>Grasshopper often converts geometrical types that are close enough upon input. In this example, <code>Construct Point</code> outputs a 3D point which is plugged into Base in <code>Sphere</code> despite Base asking for a 3D plane. In cases like these Grasshopper will automatically convert a 3D point into a plane with an origin defined by that 3D point. Other conversions happen - try plugging the 'wrong' geometry into inputs to see what happens, but don't be surprised if you get an error sometimes!</p>"},{"location":"gh/first-definition/#04-05-drawing-a-line","title":"04 / 05 - Drawing a Line","text":""},{"location":"gh/first-definition/#06-the-input-expression-editor","title":"06 - The Input Expression Editor","text":"<p>Grasshopper offers a really useful way to quickly alter numerical values on component input. Let's say we want to ensure that our widget arm is always half a wide as the widget base. To do so, we can rmb the Radius of <code>Pipe</code>, select Expression and then write a short algebraic statement in the input box. In this case we can write x / 2. This will set our radius to always be half of the input value, and since our input <code>Number Slider</code> also controls the <code>Sphere</code>'s radius, the radius of our pipe will always be the sphere radius / 2.</p> <p>Always X!</p> <p>The input Expression field can only ever contain one variable, X. If you need a more complex expression, you can always build it up outside of an input from components found in the Maths tab.</p> <p></p>"},{"location":"gh/first-definition/#07-boolean-operations","title":"07 - Boolean Operations","text":""},{"location":"gh/first-definition/#08-geometry-analysis","title":"08 - Geometry Analysis","text":"<p>Group 8 demonstrates how Grasshopper can be used for geometrical analysis, and how you can quickly build up algebraic functions. </p> <p>In this instance, our goal is to determine how far off our widget's arm length is from a user set desired length. We begin by measuring the length of the <code>Line</code> component with <code>Length</code>. We use a <code>Number Slider</code> to define the desired length. We subtract the actual length from the desired length using <code>Subtraction</code> to give us the signed difference. Since we don't care about whether the arm length is less than or greater than the desired length, we get rid of the sign using <code>Absolute</code>. Finally we use a <code>Panel</code> to get a text output of how far away we are from our goal.</p> <p></p>"},{"location":"gh/first-definition/#09-visualization","title":"09 - Visualization","text":"<p>Often, visual feedback within the Rhino viewport is the most intuitive way to display conformance with design criteria. In this instance we will color our widget with <code>Custom Preview</code>. The color that feeds into the Material input is given by <code>Gradient</code>. If the widget is red, we are far from our goal, if it is green, we are close to or at our goal length.</p> <p>Our output from <code>Absolute</code> is fed into <code>Display</code>'s Parameter. Here we are telling <code>Display</code> to return a color based on the position of <code>Absolute</code>'s output within the numerical range defined between Lower Limit and Upper Limit. By default, this range is 0 to 1. </p> <p>We don't know how far from the goal we can get, but let's start with 100 for the Upper Limit.</p> <p>Setting a Parameter Value Internally</p> <p>If you rmb on a given parameter and select Set ..., you will be able to internally set a static value.</p> <p></p> <p>Now that we've set our upper limit to 100, we will see our widget's color update as we move further and closer from our design goal!</p> <p></p>"},{"location":"gh/interface/","title":"Grasshopper Interface","text":"<p>First things, first. To open Grasshopper type  <code>grasshopper</code> into your Rhino command line, or simply click the \ud83e\udd97 icon in the standard tab.</p>"},{"location":"gh/interface/#a-first-look","title":"A First Look","text":"<p>The window that pops up should look something like the image below. Note that your window may also be overlaid with the tutorials file window. You can safely close this window as those tutorials are also stored in the Grasshopper help tab.</p> <p>The image below outlines the main areas of the user interface. Each of these areas are elaborated in the following sections. Click on the tabs below to scroll through descriptions of the sub-menus and functionalities of the Grasshopper UI.</p> <p>The Grasshopper component panels below may look slightly different</p> <p>As you progress with Grasshopper, you will add custom component panels to your interface. All of the illustrations have two custom panels: Wb (weaverbird) and Lunchbox. Don't worry that your fresh copy of Grasshopper doesn't have these two panels!</p> <p> </p> Grasshopper Interface"},{"location":"gh/interface/#main-menu-bar","title":"Main Menu Bar","text":"IntroFile tabEdit tabView tabDisplay tabSolution tabHelp tabFile browser <p>The main menu bar is similar to other programs you have encountered using windows.</p> <p> </p> <p>Warning</p> <p>Grasshopper has a tendency to freeze and/or crash while you are learning how to use it. Save often using the <code>Save</code> command under the file tab, or press Ctrl+S.</p> <p>Open one of the tutorial files under <code>Help --&gt; Tutorial Files</code> and try both the <code>export quick image</code> and <code>Export Hi-Res Image</code> commands. These can be useful for sharing your work with others. I wouldn't encourage you to include the diagrams on studio presentation boards however. Most often reviewers will not be able to make heads or tails of the spaghetti like image!</p> <p>We will return to <code>special folders</code> when we look at installing plugins, but for now just know its there.</p> <p>Finally, the <code>new document</code>, <code>open document</code>, <code>recent files</code> and <code>close</code> will behave as expected.</p> <p> </p> <p>Tip</p> <p>Most non-mac computers will be able to use the common shortcuts Ctrl+C for copy, etc. Users with mac laptops but running Rhino on Windows often have to use the commands located in <code>edit</code> in order to copy, paste, delete.</p> <p>Grasshopper's <code>copy</code>, <code>paste</code>, <code>delete</code>, <code>undo</code>, <code>redo</code>, <code>select all</code>, and <code>deselect all</code> will function as expected. Most likely, you will end up using the shortcuts. For example, +Ctrl+C+ for copy. We will get to what exactly we will be copying in the next section.</p> <p>The other commands will be covered in later sections.</p> <p> </p> <p>The view tab primarily deals with the view of the interface menus itself. Feel free to play around with settings, but know that these tutorials use default settings. </p> <p>The one section that you may find useful is <code>zoom</code>. This section allows you to zoom to different areas of your definition and the canvas.</p> <p> </p> <p>The display tab primarily deals with the was grasshopper objects are drawn in Rhino and the way Grasshopper components are drawn on the canvas.</p> <p>Tip</p> <p>For all of these tutorials we will use the default display setting minus one change. I would encourage you to enable <code>Draw Full Names</code>. This setting will render full names on your GH components. This is especially helpful for learning what each component does.</p> <p>Return to the settings after completing the Grasshopper Basics section. You may find that you prefer different display settings. For now, you can leave all other settings as default.</p> <p> </p> <p>The solution tab primarily deals with the Grasshopper solver. As data flows through your components, you can use the options in this tab to pause the solver and save states of flows.</p> <p>This section also allows you to disable, preview, and bake (bring into Rhino) the outputs of components.</p> <p>You will find that this tab is rarely used, so know it's there, but don't be surprised if you never open it again.</p> <p> </p> <p>Now, this is an important tab!</p> <p>Try it for yourself!</p> <p>While we're here. Take some time to go through the <code>tutorial files</code>. Don't worry if they don't totally make sense.</p> <p>The <code>grasshopper support</code> command will take you to the Mcneel Grasshopper Forum. It's worth searching this forum for a question you may have. Further, make an account and ask you own question if you can't find an answer!</p> <p>The <code>Online Reference</code> command will take you to the Grasshoper Components Documentation where you will find notes on every single component.</p> <p>Google is your friend</p> <p>I would encourage you to simply google \"grasshopper\" plus whatever problem you are trying to solve. Google is your friend.</p> <p>ChatGPT is your unreliable (but still useful) friend</p> <p>You can also try asking ChatGPT to describe a basic component flow and even generate a rudimentary diagram.</p> <p>Try phrasing you question as </p> <p><code>I'm using Rhino 3D grasshopper. What components could I use to make a &lt;insert your goal here&gt;? Include a diagram with your answer.</code></p> <p>You will get a step by step instruction set with a diagram that looks like this: <pre><code>  [Curve]   [Curve Length]  [Divide Curve]   [Point On Curve]\n     |             |                |                |\n     +-------------+----------------+----------------+\n                           |\n                     [Offset Curve]\n                           |\n                           +-------+\n                                   |\n                                [Loft]\n                                   |\n                                   +------+\n                                           |\n                                  [Sweep 1 Rail]\n                                           |\n                                     [Staircase Geometry]\n</code></pre> Pretty cool!</p> <p>In my testing, its answer are generally correct in approach but will contain smaller errors. This may be a good way to brainstorm but do not use ChatGPT as a crutch, especially when you are first learning.</p> <p> </p> <p>The <code>file browser</code> appears after you have opened at least one GH file. When you have more than one GH file open, you can switch between them using the <code>File browser</code> located on the right hand side of the main menu bar. You can also close files from the browser.</p>"},{"location":"gh/interface/#components-panel","title":"Components Panel","text":"IntroUsing the Components PanelParamsMathsSetsVectorCurveSurfaceMeshIntersectTransformDisplayKangaroo2 <p>Welcome to the component panel, where you can explore all the different component categories. Each component belongs to a specific category, such as \"Params\" for primitive data types or \"Curves\" for curve-related tools.</p> <p></p> <p>Each category of components is given its own panel. To switch between categories, you click the tabs on the top of the panel. For example, clicking the \u2018vector\u2019 tab will display all vector components and clicking the \u2018curve\u2019 tab will display all curve related components. Within each of these categories you will see that the components are grouped into sub-categories that further organize components.</p> <p>Since there can be a large number of components per sub-category, we only display the most commonly used ones in the main panel. If you want to see the entire collection, simply click on the dark grey bar with the little arrow at the bottom of the panel. When you click on the bar, a category panel will pop up, giving you access to all the objects. In this panel, you have two options: you can either click on the objects in the popup list, or you can directly drag them from the list onto the canvas. Personally, I prefer the click method as the drag method sometime creates two of the same components!</p> <p>Clicking on buttons will not automatically add them to the canvas. To add a component to your canvas, you must click once on the component icon, and then once again on the canvas itself.</p> <p>You can find where a component lives in the panel by holding Ctrl+Alt on your keyboard and hold clicking on a canvas component. This command will circle and arrow the exact location of the component!</p> <p>You can also double click an empty portion of the canvas to search for a component by name.</p> <p>Hover over everything!</p> <p>You can hover over components in the panel, the search bar, and on the canvas to display a text description of what said component does. Do this often, especially while you are learning!</p> <p></p> <p>This panel houses all the primitive data types, such as numbers, texts, and boolean values. You can use these components to input or generate data for your designs.</p> <p></p> <p>If you need to perform mathematical operations within Grasshopper, the Math panel is where you'll find the relevant components. It includes components for basic arithmetic, trigonometry, logarithms, and more.</p> <p></p> <p>In the Sets panel, you'll find components for working with sets and lists of data. You will primarily use the list sub-category to organize your Grasshopper data. More advanced components allow you to perform set operations on the data itself, such as union, intersection, difference, and more.</p> <p></p> <p>The Vector panel is where you'll find components related to vector operations. Vectors represent direction and magnitude, and they are fundamental in many design and computational geometry tasks. This panel provides components for creating, manipulating, and analyzing vectors within Grasshopper.</p> <p>In addition to vectors, you will also find commands related to planes and points. Planes will allow you to orient geometry while points will allow you to define specific locations in space.</p> <p>The Vector panel is particularly useful when working with geometric transformations, such as translating or orienting objects in space. You can use the components in this panel to define and manipulate vectors, planes, and points that control the direction and magnitude of these transformations.</p> <p></p> <p>In the Curves panel, you'll find a variety of tools and components related to curves. This includes components for creating, manipulating, and analyzing curves in your Grasshopper projects.</p> <p></p> <p>The Surfaces panel provides components for working with surfaces. You can create, modify, and analyze surfaces using the tools available in this panel.</p> <p></p> <p>If you're working with 3D meshes, the Mesh panel is where you'll find the necessary components. It offers tools for creating, editing, and analyzing meshes in Grasshopper</p> <p></p> <p>The Intersect panel in Grasshopper houses components for finding intersections between geometric entities. It includes tools to identify points, curves, surfaces, and other objects where they intersect or overlap. These components are vital for geometry analysis, spatial relationships, and generating complex shapes.</p> <p></p> <p>The Transform panel contains components for transforming geometry in various ways. This includes translation, rotation, scaling, and other transformations that allow you to manipulate objects in your Grasshopper projects.</p> <p></p> <p>The Display panel offers components for visualizing your data and designs. It includes components for creating 2D and 3D graphics, controlling colors, and setting up visualization parameters.</p> <p></p> <p>The Kangaroo panel in Grasshopper is dedicated to the Kangaroo physics engine, a powerful tool for simulating and modeling physical behavior within your designs. This panel contains components that enable you to apply constraints and forces to your geometry, allowing you to simulate structural, mechanical, and natural systems.</p> <p>By utilizing the Kangaroo panel's components, you can add realistic physics-based behavior to your designs, enabling you to explore and analyze how objects interact, deform, and respond to external forces. The Kangaroo panel opens up a world of possibilities for creating interactive and dynamic designs in Grasshopper.</p>"},{"location":"gh/interface/#the-canvas","title":"The Canvas","text":"IntroWorking in the canvasCanvas Widgets <p>Welcome to the Grasshopper canvas! The canvas is where your creative ideas come to life and where you bring your designs to reality. It serves as the digital workspace where you connect components, define relationships, and build intricate visual algorithms.</p> <p> </p> <p>The canvas is where we build our definitions. Rather than breaking down each command into text, we opted for a video explanation. Watch the video - pause often - try to follow along on your own computer. </p> <p></p> <p>The Grasshopper canvas provides a few widgets to enhance our workflow.</p> <p>Markov tries to guess what component we will want to use next. Simply click the icon to place the indicated component on the canvas. It makes better predictions as you work more in Grasshopper. Useful? Maybe!</p> <p>Compass orients you towards the components on your canvas. This can actually be quite useful if you are lost way out in outer extremities of the canvas.</p> <p>Profiler. By default this widget will not show. To enable it go to <code>Display -&gt; Canvas widgets -&gt; profiler</code>. This will attach a little indicator to most components indicating the time it takes the Grasshopper solver to compute the work said component is performing. This widget can be helpful to troubleshoot problem areas in your definition. Further, if you write your own components in Python or C#, the profiler also provides valuable feedback on the components performance.</p>"},{"location":"gh/intro/","title":"Welcome! \ud83e\udd97","text":""},{"location":"gh/intro/#file-downloads","title":"File Downloads","text":"<p>All GH files will be available for download. Follow the links provided with each page of instruction to download the proper file. Once you're on the linked page, click the raw download button as shown in a green rectangle below to download the <code>.gh</code> file.</p> <p> </p> Click the button in the green rectangle!"},{"location":"gh/intro/#markdown-conventions","title":"Markdown Conventions","text":"<p>These documents use a few textual conventions to help with readability.</p>"},{"location":"gh/intro/#grasshopper-components","title":"Grasshopper Components","text":"<p><code>Inline Code Text</code> refers to the name of a specific Grasshopper component. For example,  the component below would be referred to as <code>Sphere</code>.</p> <p></p>"},{"location":"gh/intro/#component-inputs-and-outputs-parameters","title":"Component Inputs and Outputs (Parameters)","text":"<p>Bolded Text refers to the parameters of a component. For example, in the image above, we see Base and Radius on the input, and Sphere on the output of <code>Sphere</code>.</p>"},{"location":"gh/intro/#component-options","title":"Component Options","text":"<p>Italicized Text refers to right click options found within the components themselves. For example, in the image below Expression would be italicized.</p> <p></p>"},{"location":"gh/intro/#mouseclicks-and-shortcuts","title":"Mouseclicks and Shortcuts","text":"<p>Mouse clicks will be represented by rmb for a right-click, and lmb for a left-click. Shortcuts will represented by their key combos. For example, Ctrl+C for copy.</p>"},{"location":"gh/intro/#admonitions","title":"Admonitions","text":"<p>Important points will be formatted like so:</p> <p>Parameters &amp; Components - What are they?</p> <p>All the little 'nodes' that make up a Grasshopper definition (script) are called components. Parameters are a class of component that either reference data from Rhino, reference data from outside of Rhino / Grasshopper, or, as in this case, reference user input.</p> <p>Common beginner traps will be formatted like so:</p> <p>Always X!</p> <p>The input Expression field can only ever contain one variable, X. If you need a more complex expression, you can always build it up outside of an input from components found in the Maths tab.</p>"},{"location":"gh/rhino-interaction/","title":"Interacting with Rhino and Basic Geometrical Concepts","text":"<p>See this Rhino file and this Grasshopper file.</p> <p>In this example, we will be looking at how we can place a tree, made with Rhino, on a surface, lofted in Grasshopper from Rhino curves. We will explore the the following important concepts:</p> <ol> <li>Referencing Rhino geometry</li> <li>Surface UVs</li> <li>Points</li> <li>Vectors</li> <li>Planes</li> </ol> <p>Our grasshopper definition looks like this:</p> <p></p> <p>Our Rhino viewport will look like this:</p> <p></p>"},{"location":"gh/rhino-interaction/#01-02-referencing-rhino-geometry","title":"01 / 02 - Referencing Rhino Geometry","text":"<p>For the last definition we looked at, we created all of our geometry within Grasshopper itself, but usually it's easier to create geometry in Rhino and then bring it into Grasshopper. This is called referencing geometry.</p> <p>For an in-depth look at referencing Rhino geometry, see this thorough write-up on Hopific.</p>"},{"location":"gh/rhino-interaction/#03-interacting-with-rhino-geometry","title":"03 - Interacting with Rhino Geometry","text":"<p>When you reference Rhino geometry in Grasshopper, you are creating a live link to that geometry. Changes that are made in Rhino will automatically update the referenced geometry in Grasshopper. Any downstream impacts within the GH definition will also update in real time.</p> <p>In our case, after referencing our curves, we can move them around, scale them, adjust their control points, etc. and all changes will be reflected in Grasshopper.</p> <p></p> <p>However, there are limitations to this live link. Grasshopper references geometry per Rhino object. If you were to split one of your referenced curves into two, Grasshopper would lose the link to the two resultant curves, as technically, two new objects are created in Rhino. In such a case, you will need to re-reference the new geometry.</p> <p></p>"},{"location":"gh/rhino-interaction/#04-surface-uv-coordinates","title":"04 - Surface UV Coordinates","text":""},{"location":"gh/rhino-interaction/#uv-coordinates-overview","title":"UV Coordinates - Overview","text":"<p>In Rhino, we are used to working with coordinates. In particular, we are used to working in a 3D Cartesian coordinate system composed of X values and Y values (the horizontal coordinates) and a Z value (the vertical coordinate). If we wanted to represent some points on our lofted surface as X,Y,Z coordinates, it would look something like:</p> <p></p> <p>This X,Y,Z coordinate system is great for a lot of things, but gets a bit clunky when we want to describe a position on the surface itself. For example, the above image shows our center point of the surface as (28, 148, 14) but wouldn't it be much easier if we could describe our center point as (0.5, 0.5)? This is where a UV coordinate system comes into play. We can describe points on the surface with a UV coordinate system like so:</p> <p></p> <p>Since we are only working with U and V dimensions, we drop any notion of elevation. In other words, this coordinate system does not describe the waviness of the surface but only the position within the surface. If you want to form a mental image, imagine a gridded blanket where you consider the lines in one direction U, and the lines in the other direction, V. Those lines still describe the same positions on the blanket, even if they're wrapped around a dog!</p> <p></p> <p>If you want to see those wavy lines in the Rhino screen, you can also run the command, <code>_ExtractIsocurve</code>.</p> <p></p>"},{"location":"gh/rhino-interaction/#uv-coordinates-reparameterization","title":"UV Coordinates - Reparameterization","text":"<p>In Grasshopper it is really useful to describe surfaces with UV coordinates ranging from 0 to 1 in both directions. It ensures that whatever wavy surface we pass into a component, we will be able to describe a location on that surface.</p> <p>If we look back to the provided file's group 4 you can see that we're using the <code>MD Slider</code> to define a UV coordinate which we feed into the Point input of <code>Evaluate Surface</code>.</p> <p></p> <p>This makes sense so far given what we've learned about UV coordinates, but why do we only see a little wiggle when we move the <code>MD Slider</code> around? We see this behavior because Grasshopper, by default doesn't assign a range of 0 --&gt; 1 to the UV directions of a surface. The UV values by default are based on XYZ values, or something like that, I think ... I've represented these random upper limits of UV with 1234 in the image below. In other words, it doesn't really matter what your initial UV system is, because you always want good old predictable 0 to 1! </p> <p></p> <p>To convert our surface's UV ranges to 0 --&gt; 1, we have to rmb the Surface input of <code>Evaluate Surface</code> and click Reparameterize. You will know see that UV coordinates output by <code>MD Slider</code> return the location on the surface that we would expect. Get used to reparameterizing surfaces all the time in Grasshopper!</p> <p></p>"},{"location":"gh/rhino-interaction/#05-bounding-boxes","title":"05 - Bounding Boxes","text":"<p>A Bounding Box is a plane-aligned box (a rectangular prism) that exactly contains the extents of a geometry. For example, in 2D, a bounding square would exactly describe the complex bounds of the below geometry like so:</p> <p></p> <p>A bounding box extends this behavior to all 3 dimensions. </p> <p></p> <p>Bounding boxes are useful for getting general dimensions of an object, or getting generalized points, among other things. In this case we are going to grab two points for from the corners of a bounding box in order to find the middle base point.</p>"},{"location":"gh/rhino-interaction/#06-points","title":"06 - Points","text":"<p>Points represent a position in space. We've already encountered the concept of UV point where a point has a U value (0--&gt;1) and a V value (0--&gt;1), but in this section we will look at 3 dimensional points. The 3D point is the type of point you will most commonly encounter in day-to-day practice.</p> <p>In step 6 of the example GH definition, we are first grabbing all the corners of the tree's <code>Bounding Box</code> with <code>Box Corners</code>. If we hover over the outputs of Corner A and Corner B, we will see that they return two points on the bottom of the box.</p> <p></p> <p>As we mentioned, 3D points have three dimensions: X, Y, and Z. The outputs A and B give us the point at X=Min, Y=Min, Z=Min and X=Max, Y=Max, and Z=Min respectively. This is how we know that the points are diagonal to each other. We can also hover over the ouputs and see the actual Rhino space coordinates of each point.</p> <p>Since points are defined by 3 coordinates each, we can perform a bit of math on them to compose new points. In the second part of step 6, we use <code>Average</code> to find the point in between the two corner points.</p> <p></p> <p>This works because we are averaging each coordinate. For example, two points \\([0,0,0]\\) &amp; \\([1,1,0]\\) would give us \\([(0+1)/2,(0+1)/2,(0+0)/2] = [0.5,0.5,0]\\)</p> <p></p> <p>Points are closely related to, but not the same as, the next topic, Vectors.</p>"},{"location":"gh/rhino-interaction/#7-8-vectors","title":"7 / 8 - Vectors","text":"<p>A Vector's textual representation looks like a point. In other words, \\([1,1,1]\\) could represent both a point and a vector.</p> <p>However vectors are very different! Whereas a point describes a coordinate in 3 dimensional space, and in Rhino, is also a geometric object, a vector describes a direction and length in 3 dimensional space. A vector can be thought of as a translation or a movement.</p> <p>Below shows points at \\([0,0,0]\\) and \\([1,1,1]\\) and a vector, \\([1,1,1]\\). Since a vector describes a translation, and is not actually a piece of geometry, the arrow is just a visual representation of the vector. In this case, we could say that a vector \\([1,1,1]\\) translates a point at \\([0,0,0]\\) to a new coordinate at \\([1,1,1]\\).</p> <p></p> <p>A vector is not tied to a specific location, like a point is. The same vector \\([1,1,1]\\) could also be used to translate a point from the coordinate \\([1,1,1]\\) to the coordinate \\([2,2,2]\\). </p> <p></p> <p>Remember, the vector arrows drawn are just visualizations of a vector - a vector does not need a start or end point. An analogy: you can tell someone to walk forward 10 steps and to the right 5 steps in either Paris or Hong Kong - the directions you give are still the same regardless of where the person starts or ends.</p> <p>See this Hopify article</p>"},{"location":"gh/rhino-interaction/#9-10-planes","title":"9 / 10 - Planes","text":"<p>See this Hopify article</p>"},{"location":"python/01_setup/overview/","title":"Temp Notes","text":""},{"location":"python/01_setup/overview/#setup","title":"Setup","text":"<p>See PCC - Ch1. up to Terminal Section See https://code.visualstudio.com/docs/datascience/jupyter-notebooks</p>"},{"location":"python/01_setup/overview/#comments","title":"Comments","text":"<p>PCC - CH2. comments</p>"},{"location":"python/01_setup/overview/#markdown","title":"Markdown","text":"<p>https://www.markdownguide.org/cheat-sheet/</p>"},{"location":"python/01_setup/overview/#customizing-environment","title":"Customizing Environment","text":"<p>https://code.visualstudio.com/docs/getstarted/themes</p>"},{"location":"python/01_setup/overview/#vs-code-shortcuts","title":"VS Code Shortcuts","text":"<p>https://dev.to/thomaslombart/vs-code-shortcuts-to-boost-your-productivity-2d7f</p>"},{"location":"python/01_setup/overview/#getting-ready-for-rhino-and-gh","title":"Getting Ready for Rhino and GH","text":"<p>Ref. GH Notes</p>"},{"location":"python/02_basics/overview/","title":"Temp Notes","text":"<p>I want to start sort of like TP. Introduce expressions, operators, and basic arithmetics.</p> <p>Unlike, TP and PCC, introduce concept of object early. Relate this to type. Go into built-in functions, and then object methods.</p> <p>Variables - still in numbers.</p> <p>And then strings.</p>"},{"location":"python/02_basics/overview/#expressions-statements-operators","title":"Expressions, Statements, Operators","text":"<p>TP - Arithmetic Expressions - this more or less will cover numbers too (TP Arithmetic Operators)[https://learning.oreilly.com/library/view/think-python/9781098155421/ch01.html#arithmetic-operators]</p> <p>Ref PCC as added reading but not essential. Explain difference between floats and numbers.</p>"},{"location":"python/02_basics/overview/#functions-objects-methods-types","title":"Functions, Objects, Methods, Types","text":"<p>TP types</p>"},{"location":"python/02_basics/overview/#strings","title":"Strings","text":""}]}